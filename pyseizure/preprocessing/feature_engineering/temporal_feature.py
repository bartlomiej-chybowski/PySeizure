import numpy as np
from typing import List
from scipy.signal import find_peaks
from scipy.stats import kurtosis, skew, iqr
from pyseizure.data_classes.feature import Feature
from numpy.lib.stride_tricks import sliding_window_view
from eeglib.features import hjorthMobility, hjorthComplexity, PFD


class TemporalFeature:
    def __init__(self,
                 raw_signal: np.array,
                 std: np.array,
                 features: List[Feature] = [Feature.MEAN]):
        self.raw_signal = raw_signal
        self.features = features
        self.std = std

    def calculate_features(self):
        result = np.array([list() for _ in range(len(self.raw_signal))])
        for feature in self.features:
            result = np.concatenate((result, getattr(self, feature.value)),
                                    axis=1)

        return result

    @property
    def mean(self):
        return np.mean(self.raw_signal, axis=1).reshape(-1, 1)

    @property
    def variance(self):
        return np.var(self.raw_signal, axis=1).reshape(-1, 1)

    @property
    def skewness(self):
        return skew(self.raw_signal, axis=1).reshape(-1, 1)

    @property
    def kurtosis(self):
        return kurtosis(self.raw_signal, axis=1).reshape(-1, 1)

    @property
    def interquartile_range(self):
        return iqr(self.raw_signal, axis=1).reshape(-1, 1)

    @property
    def min(self):
        return np.min(self.raw_signal, axis=1).reshape(-1, 1)

    @property
    def max(self):
        return np.max(self.raw_signal, axis=1).reshape(-1, 1)

    @property
    def hjorth_complexity(self):
        return np.apply_along_axis(hjorthComplexity, 1,
                                   self.raw_signal).reshape(-1, 1)

    @property
    def hjorth_mobility(self):
        return np.apply_along_axis(hjorthMobility, 1,
                                   self.raw_signal).reshape(-1, 1)

    @property
    def petrosian_fractal_dimension(self):
        return np.apply_along_axis(PFD, 1,
                                   self.raw_signal).reshape(-1, 1)

    @property
    def spike_count(self):
        threshold = self.std * 4

        result = []
        for signal, thr in zip(self.raw_signal, threshold):
            peaks, _ = find_peaks(signal, height=thr, distance=3)
            result.append(len(peaks))

        return np.array(result).reshape(-1, 1)

    @property
    def coastline(self):
        """
        The sum of the absolute changes in signal value from one sample to
        the next, divided by the number of samples in the interval, divided by
        the range of the signal in the interval.
        The range of the signal is its maximum value minus its minimum value.
        If the range is zero, we set the coastline measurement to zero also.

        Returns
        -------
        numpy.array
        """
        length = np.sum(np.abs(np.diff(self.raw_signal)), axis=1)
        samples_no = self.raw_signal.shape[1]
        signal_min = np.min(self.raw_signal, axis=1)
        signal_max = np.max(self.raw_signal, axis=1)
        line = length / samples_no / signal_max - signal_min
        line[line == np.inf] = 0

        return line.reshape(-1, 1)

    @property
    def intermittency(self):
        """
        The fraction of the coastline generated by the 10% largest steps.
        A typical value of intermittency measure for baseline EEG is 30%.

        Returns
        -------
        numpy.array
        """
        ten_percent = int(self.raw_signal.shape[1] * 0.1)
        abs_diff = np.abs(np.diff(self.raw_signal))
        idx = np.argpartition(abs_diff, -ten_percent)[:, -ten_percent:]
        sums = []
        for index, (row, i) in enumerate(zip(abs_diff, idx)):
            sums.append(np.sum(row[i]))

        length = np.sum(np.abs(np.diff(self.raw_signal)), axis=1)

        return np.array(sums).reshape(-1, 1) / length.reshape(-1, 1)

    @property
    def voltage_auc(self):
        """
        The fraction of the voltage area under the curve occupied by
        the 10 largest peaks and trough pairs in an interval.

        Returns
        -------
        numpy.array
        """
        # peaks and valleys
        signals = []
        for signal, signal_neg in zip(self.raw_signal, self.raw_signal * -1):
            peaks, _ = find_peaks(signal, distance=1)
            valleys, _ = find_peaks(signal_neg, distance=1)

            if len(peaks) > len(valleys):
                peaks = peaks[:len(valleys)]
            elif len(peaks) < len(valleys):
                valleys = valleys[:len(peaks)]

            if len(peaks) == 0 or len(valleys) == 0:
                signals.append(0)
                continue
            if peaks[0] > valleys[0]:
                idx = np.dstack((valleys, peaks)).flatten()
            else:
                idx = np.dstack((peaks, valleys)).flatten()

            local = []
            for p, v in zip(idx[::2], idx[1::2]):
                local.append((np.abs(signal[p]) + np.abs(signal[v])) * (v-p))
            ten_largest = np.sort(np.array(local))[:10]
            signals.append(ten_largest.sum() /
                           (len(signal) * (np.abs(signal.max()) +
                                           np.abs(signal.min()))))
        if np.any(np.array(signals) < 0):
            pass
        return np.array(signals).reshape(-1, 1)

    @property
    def spikiness(self):
        """
        Spikiness is the ratio of the maximum section range to the median
        section range.

        Returns
        -------
        numpy.array
        """
        sections = sliding_window_view(self.raw_signal, (1, 5))[:, ::4]
        median_range = np.median(np.sort(np.abs(np.diff(sections, axis=3))),
                                 axis=3)
        max_range = np.max(np.sort(np.abs(np.diff(sections, axis=3))), axis=3)

        return np.average(max_range / median_range, axis=1)

    @property
    def standard_deviation(self):
        return np.std(self.raw_signal, axis=1).reshape(-1, 1)

    @property
    def zero_crossing(self):
        return ((self.raw_signal[:, :-1] * self.raw_signal[:, 1:]) < 0
                ).sum(axis=1).reshape(-1, 1)

    @property
    def peak_to_peak(self):
        return np.ptp(self.raw_signal, axis=1).reshape(-1, 1)

    @property
    def absolute_area_under_signal(self):
        return np.trapz(np.abs(self.raw_signal)).reshape(-1, 1)

    @property
    def total_signal_energy(self):
        return np.sum(self.raw_signal**2, axis=1).reshape(-1, 1)
